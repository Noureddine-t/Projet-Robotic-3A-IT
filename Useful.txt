    *def dance(self, side: str = 'right', move_time: int = 3000, blocking: Optional[bool] = None) -> bool:
        '''
        Boogie, Marty! :one: :two:
        Args:
            side: 'left' or 'right', which side to start on
            move_time: how long this movement should last, in milliseconds
            blocking: Blocking mode override; whether to wait for physical movement to
                finish before returning. Defaults to the value returned by `self.is_blocking()`.
        Returns:
            True if Marty accepted the request
        '''
        result = self.client.dance(side, move_time)
        if result:
            self.client.wait_if_required(move_time, blocking)
        return result
    *def celebrate(self, move_time: int = 4000, blocking: Optional[bool] = None) -> bool:
        '''
        Coming soon! Same as `wiggle()` for now. :one: :two:
        Args:
            move_time: how long this movement should last, in milliseconds
            blocking: Blocking mode override; whether to wait for physical movement to
                finish before returning. Defaults to the value returned by `self.is_blocking()`.
        Returns:
            True if Marty accepted the request
        '''
        result = self.client.celebrate(move_time)
        if result:
            self.client.wait_if_required(move_time, blocking)
        return result
            def eyes(self, pose_or_angle: Union[str, int], move_time: int = 1000, blocking: Optional[bool] = None) -> bool:
        '''
    *def eyes(self, pose_or_angle: Union[str, int], move_time: int = 1000, blocking: Optional[bool] = None) -> bool:
        '''
        Move the eyes to a pose or an angle :one: :two:
        Args:
            pose_or_angle: 'angry', 'excited', 'normal', 'wide', or 'wiggle' :two: - alternatively
                           this can be an angle in degrees (which can be a negative number)
            move_time: how long this movement should last, in milliseconds
            blocking: Blocking mode override; whether to wait for physical movement to
                finish before returning. Defaults to the value returned by `self.is_blocking()`.
        Returns:
            True if Marty accepted the request
        '''
        result = self.client.eyes(Marty.JOINT_IDS['eyes'], pose_or_angle, move_time)
        if result:
            self.client.wait_if_required(move_time, blocking)
        return result
    *def arms(self, left_angle: int, right_angle: int, move_time: int, blocking: Optional[bool] = None) -> bool:
        '''
        Move both of Marty's arms to angles you specify :one: :two:
        Args:
            left_angle: Angle of the left arm (degrees -100 to 100)
            right_angle: Position of the right arm (degrees -100 to 100)
            move_time: how long this movement should last, in milliseconds
            blocking: Blocking mode override; whether to wait for physical movement to
                finish before returning. Defaults to the value returned by `self.is_blocking()`.
        Returns:
            True if Marty accepted the request
        '''
        result = self.client.arms(left_angle, right_angle, move_time)
        if result:
            self.client.wait_if_required(move_time, blocking)
        return result
    *def is_blocking(self) -> bool:
        '''
        Check the default movement command behaviour of this Marty.  :one: :two:
        Returns:
            `True` if movement commands block by default
        '''
        return self.client.is_blocking()

    *def set_blocking(self, blocking: bool):
        '''
        Change whether movement commands default to blocking or non-blocking behaviour
        for this Marty.  :one: :two:

        The blocking behaviour can also be specified on a per-command basis using the
        `blocking=` argument which takes precedence over Marty's overall setting.

        Args:
            blocking: whether or not to block by default
        '''
        self.client.set_blocking(blocking)
    *def get_distance_sensor(self) -> Union[int, float]:
        '''
        Get the latest value from the distance sensor :one: :two:
        Returns:
            The distance sensor reading. The meaning of the returned value is different
            between Marty V1 and V2:
                - :one: Returns a raw distance sensor reading as a `float`.
                - :two: Returns the distance in millimeters as `int`.
            Both will return 0 if no distance sensor is found.
        '''
        return self.client.get_distance_sensor()
    *def foot_on_ground(self, add_on_or_side: str) -> bool:
        '''
        Checks whether the foot is on a surface :two:
        Args:
            add_on_or_side: Takes in the name of a color sensor, name of an IR sensor, `'left'` for the add on connected to the left foot,
             or `'right'` for the add on connected to the right foot.
        Returns:
            A boolean for whether the addon detects the ground. `True` for ground detected, `False` otherwise.
        '''
        return self.client.foot_on_ground(add_on_or_side)

    *def foot_obstacle_sensed(self, add_on_or_side: str) -> bool:
        '''
        Checks whether there is an obstacle in front of the foot :two:
        Args:
            add_on_or_side: Takes in the name of a color sensor, name of an IR sensor, `'left'` for the add on connected to the left foot,
             or `'right'` for the add on connected to the right foot.
        Returns:
            A boolean for whether the addon detects and obstacle. `True` for obstacle detected, `False` otherwise.
        '''
        return self.client.foot_obstacle_sensed(add_on_or_side)

    *def get_obstacle_sensor_reading(self, add_on_or_side: str) -> int:
        '''
        Gets a raw obstacle sensor reading from an IR or color sensor :two:
        Args:
            add_on_or_side: Takes in the name of a color sensor, name of an IR sensor, `'left'` for the add on connected to the left foot,
             or `'right'` for the add on connected to the right foot.
        Returns:
            Raw reading of obstacle sensor data from the add on.
        '''
        return self.client.get_obstacle_sensor_reading(add_on_or_side)

    *def get_color_sensor_color(self, add_on_or_side: str) -> int:
        '''
        Gets the colour detected by a colour sensor :two:
        Args:
            add_on_or_side: Takes in the name of a color sensor `'left'` for the add on connected to the left foot,
             or `'right'` for the add on connected to the right foot.
        Returns:
            one of  "yellow", "green", "blue", "purple", "red", "air", "unclear"
        '''
        return self.client.get_color_sensor_color(add_on_or_side)

    *def get_color_sensor_hex(self, add_on_or_side: str) -> str:
        '''
        Gets the colour detected by a colour sensor :two:
        Args:
            add_on_or_side: Takes in the name of a color sensor `'left'` for the add on connected to the left foot,
             or `'right'` for the add on connected to the right foot.
        Returns:
            The hex code of the colour detected by the sensor
        '''
        return self.client.get_color_sensor_hex(add_on_or_side)

    *def get_color_sensor_value_by_channel(self, add_on_or_side: str, channel: str) -> int:
        '''
        Gets the value of a colour sensor channel :two:
        Args:
            add_on_or_side: Takes in the name of a color sensor `'left'` for the add on connected to the left foot,
             or `'right'` for the add on connected to the right foot.
            channel: Takes in the name of a channel `'clear'` `'red'`, `'green'`, or `'blue'`
        Returns:
            The value of the channel
        '''
        return self.client.get_color_sensor_value_by_channel(add_on_or_side, channel)

    *def get_ground_sensor_reading(self, add_on_or_side: str) -> int:
        '''Gets a raw ground sensor reading from an IR or color sensor :two:
        Args:
            add_on_or_side: Takes in the name of a color sensor, name of an IR sensor, `'left'` for the add on connected to the left foot,
             or `'right'` for the add on connected to the right foot.
        Returns:
            Raw reading of ground sensor data from the add on.
        '''
        return self.client.get_ground_sensor_reading(add_on_or_side)

    *def get_battery_remaining(self) -> float:
        '''
        Get the battery remaining percentage :two:
        Returns:
            The battery remaining capacity in percent
        '''
        return self.client.get_battery_remaining()